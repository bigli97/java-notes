## 知识点汇总

#### **String**

不可变对象，被final修饰，对象一旦创建就不可更改

java是采用Uinicode字符集，一个字符占两个字节(Unicode是变长)

采用直接量方式，在内存中有一个String常量池，若有该类型字符串就直接重用若没有创建新的字符串，(创建的字符串是公共的)

创建的对象是存在堆中(强制创建对象)

String StringBuilder StringBuffer 三者区别String 对象不可修改

其他为变量，可以追加，删除，修改，详细之后总结

 

#### 正则

正则表达式不关心内容是否有效，只关心**格式是否匹配**

例如判断邮箱格式"[a-zA-Z0-9]+@[a-zA-z0-9]+.[a-zA-z]+"

 

#### 时间

格式yyyy:MM:dd HH:mm:ss(月份大写，小时---大写24小时制，小写12小时制)

计算活了多少天，使用毫秒计算

 

#### Object类

超类，所有类的父类，直接或间接继承(换言之只要是对象都能.出东西来)

toString() 没重写前输出的一定是地址值

 

#### 包装类

**含义**

- 包装类是不可变的类，一旦构造的对象就不可改变内部的值
- 解决不能参与面向对象编程(多态)包装类是在lang包下
- 除了Character和Boolean继承Object外，其他六种包装类都继承于Number(抽象类)

**作用**：可以参与面向编程。自动拆装箱始于JDK1.5版本



#### file

**作用**：

- 访问文件或目录的属性(名字，大小，修改时间等)
- 操作文件或目录(创建，删除)
- 访问一个目录的子项
- 不能读写数据！

##### 删除目录

由于delete方法删除目录要求必须是一个空目录 那么在是情况中，我们需要先将一个要删除的目录清空才可以进行删除(递归)



#### 异常

当调用一个含有throws声明异常抛出的方法时，编译器要求**必须**处理

这个异常而处理方式有两种

- 使用try-catch处理该异常
- 在当前方法上继续声明throws将该异常抛出

重写的时候不允许抛出额外的异常和抛出比父类方法大的异常(两小中的其中一个)



```java
try{

代码片段，只要异常try中下面的语句将不会被执行

}catch(异常类型){

异常后走这，不异常不走

}finally{

无论是否异常都执行，try中有return也走

(通常会将无论是否出现的异常都要运行的代码放在finally中)

(比如IO操作中的关闭流)

}
```

 

#### RandomAccessFile

该类设计用来专门读写文件数据。

其基于指针进行读写总是在指针当前位置读或者写字节

需要注意的是这货是流但不是IO流，它继承于Object类

r:只读

rw：可读可写

-1表示读到了末尾

GBK:国标编码，中文占2字节

UTF-8:万国码，对Unicode进行编码，变长编码集英文1字节，中文3字节

ISO8829-1:欧洲编码集，不支持中文

 

#### 线程

创建线程的方法(推荐使用**匿名内部类**)：

##### 继承Thread类

```java
Thread t = new Thread(){
    public void run(）{
    //重写run方法
    }
};
```

存在不足：

- 由于java是单继承的，这就导致在实际开发中我们往往需要继承某个类复用方法，而当前类又需要并发运行，导致不能同时又继承又复用方法的类又继承线程
- 定义线程的而同时重写run方法定义任务，这就导致了线程和任务 有一个必然耦合关系。不利于线程的重用。

（使用匿名内部类不足就不存在了）

##### 实现Runnable接口

```java
Runnable r = new Runnable(){
    public void run(){
    //重写run方法
    }
};
```

##### 守护线程

守护线程又称为后台线程，一个线程创建出来默认都是普通(前台线程),守护线程需要在线程启动前单独进行设置使用上守护线程与普通线程无差别，但是在结束时机上有一点不同。即：当进程结束时，所有正在运行的守护线程都会被强制终端进程结束：当一个进程中的所有前台线程都结束时，进程即结束

##### 线程优先级

线程之所以能够并发运行，是靠线程调度的工作，线程调度会分配cpu时间片给某个线程，使得其可以运行。线程不能主动获取cpu时间。调整线程的优先级可以最大程度的改善某个线程获取cpu时间片的次数，理论上优先级越高的线程获取的cpu时间片的次数越多线程的优先级由数字1-10表示。1是最低优先级，10为最高优先级，5为默认值。

##### 同步

被synchronized修饰后该方法称为同步方法。即：多个线程不能同时在方法内部执行从而解决了并发安全问题

synchronized（同一个对象）

有效的**缩小同步范围**可以保证并发安全的前提下尽可能提高效率

```java
Synchronized（同步监听器）{
需要同步的代码块
}
```

同步监视器时java中任意的一个对象，只要保证多个线程看到的该对象是    “同一个”，即可保证同步块中的代码是并发发生的。

静态方法若使用synchroinzed修饰后，那么该方法一定具有同步效果,因为他里面只有一份方法

 

##### 互斥

当使用synchrinized锁住多端不同的代码片段，但是这些同步块使用的同步监视器对象是同一个时，那么这些代码片段之间就是互斥的。多个线程不能同时执行他们（总结就是在执行一个的时候另一个进不去）

 

##### 死锁

当多个线程都持有自己的锁，但是都等对方先释放锁时就会出现“僵持”的情况，使得所有的线程进入阻塞状态。这个现象称为死锁现象。（总结就是两个互不释放刚着了）

 

#### 集合

collection是所有集合的顶级接口，规定了所有集合都应当具备的方法下有两个常用的派生接口：

java.util.List:可重复集合，并且有序。

（ps:有序是指输什么出什么比如2，3，1，输出的就是2，3，1不是自动排成1，2，3）

java.util.Set:不可重复集合，并且无序。

（ps:无序是指输什么出什么不一定出什么比如2，3，1，输出的不一定是2，3，1）

 

##### 数组转集合

对数组转换的集合进行操作，就是对原数组对应操作增删元素是不支持的操作因为会导致数组扩容或者缩容那样就无法表示数组。可以自行创建一个集合，然后做操作。 (数组转的集合不能操作，要操作就得在弄个集合)

##### 集合转数组

String[] s = c.toArray(new String[c.size()]);

##### 集合的排序

collections的sort方法在排序集合时要求集合元素必须实现comparable接口，但使用它排序存在不足：(尽量少用)

- 该方法要求集合元素必须实现comparable接口，这在实际开发中时不太可取的因为该功能会对我们写的代码有侵入性（侵入性解释:当我们调用某个功能时，该功能要求我们为其修改代码修改的地方越多，侵入性越高，不利于程序扩展和后期维护。）
- 若元素已经实现了comparable接口并定义了比较规则，但是规则不满足我们的排序需求时该方法就无法使用。比如排序字符串，只能按照字符Unicode编码排序。排序中文时则没什么意义。

**Collection**提供了一个重载的方法(用这个)

除了传入一个集合，在传入一个排序规则，好处如下：

该方法不再要求元素必须实现comparable接口，从而对元素没有侵入性。并且由于使用该比较规则排序集合，所以也就不再需要元素自身的比较规则，那么元素自身比较规则不满足排序需求的问题也就得到解决。

```java
Collections. sort (list, new Comparator<String>(){
    public int compare(String sl,String s2){ 
        return sl.length() - s2.length()
    }
});
```

**队列：**队列可以存放一组元素，但是存取必须按照先进先出原则。Queue是一个接口，其继承自collection，所以队列也具有集合的特性add，size等方法依然可用，但建议使用offer(入队)poll(出队)

**栈：**栈可以保存一组元素，存取元素必须遵循先进后出的原则add，size等方法依然可用，但建议使用push(入栈)poll(出栈)

 ## API操作

#### String(str)

Str.charAt(2)；//返回第三个字符串的字符

str.indexOf("a")//返回第一次出现a的下标

Str.substring(3)//从当前下标开始截取字串(包含给定下标)

Str.substring(3,6)//含头不含尾

Str.trim()//去除字符串两边的空白

Str.toUpperCase()//将字符串变成大写

Str.toLowerCase()//将字符串变成小写

Str.valueOf(i)//将字符串转换为基本数据类型

Str.endwith(“1”)//判断是否以1结尾

Str.startwith(“京”)//判断是否以京开头

String[] s = str.split("1")//将str字符串从1分开不包含1

Arrays.toString(数组)//将数组中的内容转换为字符串

 

#### File(file)

file.exits()//判断文件目录是否已经存在

file.creatNewFile()//创建新的文件

file.mkdir()//创建一个目录

file.mkdirs()//创建一堆目录

file.listFiles()//返回值为File[] 文件列表

file.delete()//删除目录

file.isFile(); // 判断是否为文件

file.isDirectory() //判断是否为目录

 

#### RandomAccessFile(raf)

raf.write()//写文件

raf.read()//读文件

raf.seek(long)//将指针指定到指定位置等待操作

raf.getFilePointer()//获得指针当前位置

raf.readLong()//读当前指针所在的位置

 

#### 线程

Thread.currentThread()//返回当前正在执行的线程对象的引用

Thread.sleep(a)//阻塞a毫秒

t.start()//启动线程

t.setDeamon(true)//成为守护线程

t.join()//一般放到t以外别的线程中t线程完了，别的才可以运行

t.setPriority(5)//将线程优先级设置为5

t.interrupt()//中断一个正在运行的线程,若该线程正处于某种阻塞时被调用,会抛出中断异常

 

#### 集合

Arrays.asList(s)//将s数组转换为一个list集合。

String[] s = c.toArray(new String[c.size()])//数组转集合

Arrays.toString(s)//s为String[]数组，遍历数组，相当于for

c1.containsAll(c2)//判断c1集合是否全部包含c2的全部元素

c1.addAll(c2)//将c2的全部元素添加到c1中

c.size()//集合的长度

c.clear()//清除集合中的所有元素

c.isEmpty()//判断是否为空集

collections.shuffle(list)//乱序

c.contains(p)//判断c集合是否包含p元素

queue.peek（）//引用队首元素

一般集合.add(x)添加元素

一般集合.remove(x)删除元素

队列.offer(x)入队操作

队列.poll(x)出队操作

栈.push()入栈

栈.pop()弹栈