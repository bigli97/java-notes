# 总结

#### 1.条件/三目

boolean?数1:数2 ----- true为数1，false为数2



#### 2.方法的重写(Override):重新写、覆盖

 1)发生在父子类中，方法名称相同，参数列表相同，方法体不同

 2)重写方法被调用时，看对象的类型

 3)遵循"两同两小一大"原则:

  3.1)两同:

​      3.1.1)方法名称相同

​        3.1.2)参数列表相同

​    3.2)两小:

​     3.2.1)派生类方法的返回值类型小于或等于超类方法的

​           1)void时，必须相等

​             2)基本类型时，必须相等

​             3)引用类型时，小于或等于

​    3.3)一大:

​      3.3.1)派生类方法的访问权限大于或等于超类方法的

![image-20201223182726589](https://gitee.com/leidl97/picture/raw/master/img/20201223182726.png)

![image-20201223182729830](https://gitee.com/leidl97/picture/raw/master/img/20201223182726.png)

![image-20201223182733903](https://gitee.com/leidl97/picture/raw/master/img/20201223182726.png)

#### 3.重写和重载的区别

重写(Override):

 1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同

1.2)遵循"运行期"绑定，看对象的类型来调用方法

 2)重载(Overload):

 2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同

​    2.2)遵循"编译期"绑定，看参数/引用的类型来绑定方法![image-20201223182749814](https://gitee.com/leidl97/picture/raw/master/img/20201223182749.png)

#### 4..static:静态的

 1)静态变量:

  1.1)由static修饰

​    1.2)属于类的，存储在方法区中，只有一份

​    1.3)常常通过类名点来访问

​    1.4)何时用:所有对象所共享的数据(图片、音频、视频等)

 2)静态方法:

  2.1)由static修饰

​    2.2)属于类的，存储在方法区中，只有一份

​    2.3)常常通过类名点来访问

​    2.4)静态方法没有隐式的this传递（this对象而static是类）

​      所以在静态方法中不能直接访问实例成员

​    2.5)何时用:方法的操作仅与参数相关而与对象无关

 3)静态块:

  3.1)属于类的，在类被加载期间自动执行的，

​      因类只被加载一次，所以静态块也只执行一次

​    3.2)何时用:初始化/加载静态资源(图片、音频、视频等)



#### 5.抽象类:

 1)由abstract修饰

 2)包含抽象方法的类必须是抽象类

  不包含抽象方法的类也可以声明为抽象类

 3)不能被实例化

 4)抽象类是需要被继承的，派生类:

  4.1)重写抽象类中的所有抽象方法-----变不完整为完整

​    4.2)也声明为抽象类-----------------不常用

 5)抽象类的意义:

  5.1)封装派生类所共有的属性和行为--------代码复用

​    5.2)为所有派生类提供一种统一的类型------向上造型

​    5.3)可以包含抽象方法，为所有派生类提供统一的入口，

​      派生类的具体行为不同，但入口是一致的



#### 6.接口:

 1)是引用数据类型

 2)由interface定义

 3)只能包含常量和抽象方法

 4)接口不能被实例化

 5)接口是需要被实现/继承的，实现类/派生类:

   必须重写接口中的所有抽象方法

 6)一个类可以实现多个接口，用逗号分隔

  若又继承又实现时，应先继承后实现

接口可以继承接口



 #### 7.多态:

 1)意义:

  1.1)同一类型的引用在指向不同的对象时，有不同的实现

![image-20201223182825821](https://gitee.com/leidl97/picture/raw/master/img/20201223182825.png)

1.2)同一个对象被造型为不同的类型时，有不同的功能

​      ------对象的多态:我，水...

 2)向上造型:

  2.1)超类型的引用指向派生类的对象

​    2.2)能造型成为的类型有: 超类+所实现的接口

​    2.3)能点出来什么，看引用的类型

![image-20201223182836514](https://gitee.com/leidl97/picture/raw/master/img/20201223182825.png)

3)强制类型转换，成功的条件只有如下两种:

  3.1)引用所指向的对象，就是该类型

​    3.2)引用所指向的对象，实现了该接口/继承了该类

 4)强转若不符合如上两个条件，则发生ClassCastException类型转换异常，

建议:强转之前instanceof判断引用指向的对象是否是该类型

![image-20201223182845637](https://gitee.com/leidl97/picture/raw/master/img/20201223182845.png)

#### 8.内存管理

1)堆:

  1.1)用于存储new出来的对象(包括实例变量)

​    1.2)垃圾:没有任何引用所指向的对象

​       垃圾回收器(GC)不定时到内存中清扫垃圾，

​    回收的过程是透明的(看不到的)，不一定一发现垃圾就立刻回收，

​        调用System.gc()可以建议虚拟机尽快调度GC来回收

​    1.3)内存泄漏:不再使用的内存还没有被及时的回收

​          严重的泄漏会导致系统的崩溃

​        建议:对象不再使用时及时将引用设置为null

​    1.4)实例变量的生命周期:

​       创建对象时存在堆中，对象被回收时一并被回收

 2)栈:

  2.1)存储正在调用的方法中的所有局部变量(包括参数)

​    2.2)调用方法时在栈中为该方法分配一块对应的栈帧，

​      栈帧中存储方法的局部变量(包括参数)，

​        方法执行结束后，栈帧被清除，局部变量一并被清除

​    2.3)局部变量的生命周期:

​       调用方法时存储在栈中，方法结束栈帧被清除时一并被清除

 3)方法区:

  3.1)用于存储.class字节码文件(包括方法、静态变量)

​     3.2)方法只有一份，需要通过this来指代具体的对象

![image-20201223182909358](https://gitee.com/leidl97/picture/raw/master/img/20201223182909.png)

#### 9.面向对象三大特征

1.封装:

 1)类:封装的是对象的属性和行为

 2)方法:封装一段特定的业务逻辑功能

 3)访问控制修饰符:封装的是具体的访问权限

2.继承:

 1)作用:代码复用

 2)超类:所有派生类所共有的属性和行为

  接口:部分派生类所共有的行为

​    派生类:派生类所特有的属性和行为

 3)传递性、单一继承，多接口实现

3.多态:

 1)行为多态(所有抽象方法)、对象多态(所有对象)

 2)向上造型、强制类型转换(想访问派生类所特有的)、instanceof判断

 3)多态的表现形式:

  3.1)重写:根据对象的不同来多态

​    3.2)重载:根据参数的不同来多态